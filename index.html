<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vessel Reformed - Interactive WebGL Fluid Simulation</title>
    
    <!-- SEO & Metadata -->
    <meta name="description" content="Explore Vessel Reformed, a real-time interactive WebGL fluid simulation. Manipulate liquid physics, viscosity, and lighting in this generative art experience.">
    <meta name="keywords" content="Vessel Reformed, WebGL simulation, fluid dynamics, generative art, interactive shader, GLSL, browser arcade, 3D liquid, creative coding, physics simulation">
    <meta name="author" content="Chris Pirillo">
    <meta name="robots" content="index, follow">
    <meta name="theme-color" content="#050101">
    <link rel="canonical" href="https://pirillo.com/arcade/vessel-reformed.html">

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://pirillo.com/arcade/vessel-reformed.html">
    <meta property="og:title" content="Vessel Reformed">
    <meta property="og:description" content="Explore Vessel Reformed, a real-time interactive WebGL fluid simulation. Manipulate liquid physics, viscosity, and lighting in this generative art experience.">
    <meta property="og:image" content="https://pirillo.com/arcade/images/vessel-reformed.png">
    <meta property="og:site_name" content="Chris Pirillo's Arcade">

    <!-- Twitter -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@ChrisPirillo">
    <meta name="twitter:creator" content="@ChrisPirillo">
    <meta name="twitter:url" content="https://pirillo.com/arcade/vessel-reformed.html">
    <meta name="twitter:title" content="Vessel Reformed">
    <meta name="twitter:description" content="Explore Vessel Reformed, a real-time interactive WebGL fluid simulation. Manipulate liquid physics, viscosity, and lighting in this generative art experience.">
    <meta name="twitter:image" content="https://pirillo.com/arcade/images/vessel-reformed.png">

    <!-- Structured Data (JSON-LD) -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebApplication",
      "name": "Vessel Reformed",
      "url": "https://pirillo.com/arcade/vessel-reformed.html",
      "description": "An interactive, real-time WebGL fluid simulation allowing users to manipulate liquid physics, colors, and lighting.",
      "image": "https://pirillo.com/arcade/images/vessel-reformed.png",
      "author": {
        "@type": "Person",
        "name": "Chris Pirillo",
        "url": "https://pirillo.com",
        "sameAs": [
          "https://twitter.com/ChrisPirillo",
          "https://www.youtube.com/user/lockergnome"
        ]
      },
      "genre": "Simulation",
      "applicationCategory": "MultimediaApplication",
      "operatingSystem": "Any with WebGL 2 support",
      "offers": {
        "@type": "Offer",
        "price": "0",
        "priceCurrency": "USD"
      }
    }
    </script>

    <!-- Google Analytics -->
    <link rel="preconnect" href="https://www.googletagmanager.com">
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-1CQ4D3VQ3L"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-1CQ4D3VQ3L');
    </script>

    <style>
        :root {
            --bg-color: #050101; 
            --panel-bg: rgba(15, 10, 10, 0.95); 
            --text-color: #e0d0d0;
            --accent-color: #d10000; 
            --font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
        }

        body {
            margin: 0;
            overflow: hidden;
            background: var(--bg-color);
            color: var(--text-color);
            font-family: var(--font-family);
            user-select: none;
            -webkit-user-select: none;
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            outline: none;
        }

        #fade-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: black;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.4s ease-in-out;
            z-index: 50;
        }

        #menu-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 80; 
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 10px;
            cursor: pointer;
            backdrop-filter: blur(5px);
            transition: transform 0.2s, opacity 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #menu-btn:hover {
            background: rgba(50, 50, 50, 0.8);
            transform: scale(1.05);
        }

        #menu-btn svg {
            fill: #e0d0d0;
            width: 24px;
            height: 24px;
            display: block;
        }
        
        body.menu-open #menu-btn {
            opacity: 0;
            pointer-events: none;
        }

        #settings-panel {
            position: fixed;
            top: 0;
            right: 0;
            width: 340px;
            height: 100%;
            background: var(--panel-bg);
            backdrop-filter: blur(15px);
            box-shadow: -5px 0 20px rgba(0,0,0,0.5);
            transform: translateX(100%);
            transition: transform 0.3s cubic-bezier(0.25, 1, 0.5, 1);
            z-index: 90;
            border-left: 1px solid rgba(255,255,255,0.05);
            display: flex;
            flex-direction: column;
        }

        #settings-panel.open {
            transform: translateX(0);
        }

        .panel-header {
            flex: 0 0 70px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 24px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            background: rgba(15, 10, 10, 0.6);
        }

        .panel-title {
            font-size: 14px;
            letter-spacing: 2px;
            text-transform: uppercase;
            font-weight: 700;
            color: #e0d0d0;
            opacity: 0.9;
        }

        .panel-close-btn {
            cursor: pointer;
            padding: 8px;
            margin-right: -8px;
            border-radius: 50%;
            transition: background 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .panel-close-btn:hover {
            background: rgba(255,255,255,0.1);
        }

        .panel-close-btn svg {
            fill: #e0d0d0;
            width: 24px;
            height: 24px;
        }

        .panel-scroll-area {
            flex: 1;
            overflow-y: auto;
            padding: 24px;
        }

        .control-group {
            margin-bottom: 24px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            padding-bottom: 15px;
        }
        
        .control-group:last-child {
            border-bottom: none;
        }

        .control-group h3 {
            margin: 0 0 12px 0;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            color: #885555;
            font-weight: 700;
        }

        .control-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 14px;
            font-size: 13px;
        }

        input[type="range"] {
            width: 55%;
            accent-color: var(--accent-color);
            cursor: pointer;
            background: rgba(255,255,255,0.1);
            height: 4px;
            border-radius: 2px;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: var(--text-color);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
        }

        input[type="color"] {
            border: none;
            width: 40px;
            height: 25px;
            cursor: pointer;
            background: none;
            border-radius: 4px;
        }

        input[type="checkbox"] {
            accent-color: var(--accent-color);
            transform: scale(1.2);
            cursor: pointer;
        }

        .action-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 10px;
        }

        button.action-btn {
            width: 100%;
            padding: 12px;
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            color: var(--text-color);
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        button.action-btn:hover {
            background: rgba(255,255,255,0.15);
            border-color: rgba(255,255,255,0.3);
        }

        button.primary {
            background: rgba(209, 0, 0, 0.3);
            border-color: rgba(209, 0, 0, 0.5);
            color: white;
        }

        button.primary:hover {
            background: rgba(209, 0, 0, 0.5);
        }
        
        button.full-width {
            grid-column: span 2;
        }
        
        .value-display {
            font-family: monospace;
            font-size: 11px;
            opacity: 0.7;
        }
        
        #file-input { display: none; }

    </style>
</head>
<body>

    <canvas id="glcanvas" role="img" aria-label="Interactive 3D Fluid Simulation"></canvas>
    <div id="fade-overlay"></div>
    <input type="file" id="file-input" accept=".json">

    <!-- Hamburger Button -->
    <div id="menu-btn" role="button" aria-label="Open Settings Menu" tabindex="0">
        <svg viewBox="0 0 24 24" aria-hidden="true">
            <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
        </svg>
    </div>

    <!-- Settings Panel -->
    <aside id="settings-panel">
        <!-- Locked Header -->
        <header class="panel-header">
            <div class="panel-title">Vessel Reformed</div>
            <div class="panel-close-btn" id="panel-close-btn" role="button" aria-label="Close Settings Menu" tabindex="0">
                <svg viewBox="0 0 24 24" aria-hidden="true">
                    <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
                </svg>
            </div>
        </header>

        <!-- Scrollable Content -->
        <div class="panel-scroll-area">
            <div class="control-group">
                <h3>Actions</h3>
                <div class="action-grid">
                    <button class="action-btn primary full-width" id="btn-randomize">Randomize</button>
                    <button class="action-btn" id="btn-save">Save</button>
                    <button class="action-btn" id="btn-load">Load</button>
                    <button class="action-btn" id="btn-reset">Reset</button>
                    <button class="action-btn" id="btn-export">Export 4K</button>
                </div>
            </div>

            <div id="dynamic-controls"></div>
            
            <div class="control-group">
                <h3>Auto Advance</h3>
                <div class="control-row">
                    <label>Enable</label>
                    <input type="checkbox" id="auto-advance-toggle">
                </div>
                <div class="control-row">
                    <label>Interval</label>
                    <input type="range" id="auto-advance-timer" min="2" max="60" value="10" step="1">
                    <span class="value-display" id="timer-display">10s</span>
                </div>
            </div>
        </div>
    </aside>

    <script>
        /**
         * APPLICATION STATE & CONFIGURATION
         */
        const canvas = document.getElementById('glcanvas');
        const gl = canvas.getContext('webgl2', { preserveDrawingBuffer: true });
        const overlay = document.getElementById('fade-overlay');
        const settingsPanel = document.getElementById('settings-panel');
        const menuBtn = document.getElementById('menu-btn');
        const closeBtn = document.getElementById('panel-close-btn');
        const dynamicControls = document.getElementById('dynamic-controls');
        const fileInput = document.getElementById('file-input');

        if (!gl) {
            document.body.innerHTML = '<div style="color:white;text-align:center;padding-top:50px;">WebGL 2 Not Supported</div>';
            throw new Error("WebGL 2 not supported");
        }

        // Updated Defaults from latest user JSON
        const defaultConfig = {
            colPrimary: { type: 'color', value: '#470000', label: 'Primary (Base)' },
            colDeep: { type: 'color', value: '#4d0003', label: 'Deep (Glow)' },
            colLight: { type: 'color', value: '#000000', label: 'Highlight' },
            colEdge: { type: 'color', value: '#ff0000', label: 'Edge Color' },
            
            // Camera
            camZoom: { type: 'float', value: 2.3, min: 0.5, max: 4.0, step: 0.1, label: 'Field of View (FOV)' },
            camRadius: { type: 'float', value: 6.4, min: 2.0, max: 30.0, step: 0.1, label: 'Camera Dist' },
            viewAngle: { type: 'float', value: 0.42, min: 0.0, max: 1.56, step: 0.01, label: 'Orbit Angle' },
            
            // Shape
            cylinderRadius: { type: 'float', value: 11.6, min: 2.0, max: 20.0, step: 0.1, label: 'Liquid Spread' }, 
            twistIntensity: { type: 'float', value: -1.7, min: -3.0, max: 3.0, step: 0.1, label: 'Twist Str.' },
            vortexDepth: { type: 'float', value: 0.0, min: 0.0, max: 3.0, step: 0.1, label: 'Vortex Depth' },
            
            // Style
            chaos: { type: 'float', value: 2.0, min: 0.0, max: 2.0, step: 0.05, label: 'Organic Chaos' },
            viscosity: { type: 'float', value: 0.37, min: 0.0, max: 1.0, step: 0.01, label: 'Viscosity' },
            liquidity: { type: 'float', value: 0.08, min: 0.0, max: 1.0, step: 0.01, label: 'Liquidity' },
            metalness: { type: 'float', value: 0.9, min: 0.0, max: 1.0, step: 0.01, label: 'Metallic / Edge' },
            translucency: { type: 'float', value: 1.0, min: 0.0, max: 1.0, step: 0.01, label: 'Translucency' },
            wineTone: { type: 'float', value: 1.0, min: 0.0, max: 1.0, step: 0.01, label: 'Wine Tone' },
            
            // Waves
            waveAngFreq: { type: 'float', value: 1.0, min: 0.0, max: 10.0, step: 1.0, label: 'Ang. Freq' },
            waveAngAmp: { type: 'float', value: 0.19, min: 0.0, max: 0.3, step: 0.01, label: 'Ang. Amp' },
            waveRadFreq: { type: 'float', value: 7.0, min: 0.0, max: 20.0, step: 0.5, label: 'Rad. Freq' },
            waveRadAmp: { type: 'float', value: 0.02, min: 0.0, max: 0.3, step: 0.01, label: 'Rad. Amp' },
            
            // Motion
            timeScale: { type: 'float', value: 1.0, min: 0.0, max: 2.0, step: 0.1, label: 'Time Scale' },
            twistSpeed: { type: 'float', value: 0.5, min: -5.0, max: 5.0, step: 0.1, label: 'Twist Spd' }, // Allow neg
            waveSpeed: { type: 'float', value: 0.0, min: -5.0, max: 5.0, step: 0.1, label: 'Wave Spd' }, // Allow neg
            fluidity: { type: 'float', value: 0.8, min: 0.0, max: 2.0, step: 0.1, label: 'Fluidity' },

            // Lighting
            roughness: { type: 'float', value: 0.059, min: 0.001, max: 1.0, step: 0.001, label: 'Roughness' },
            specular: { type: 'float', value: 3.9, min: 0.0, max: 10.0, step: 0.1, label: 'Specular' },
            lightY: { type: 'float', value: 20.0, min: 1.0, max: 30.0, step: 0.5, label: 'Light Height' }
        };

        let state = {};
        
        // Generative Seed State
        let currentSeed = Math.random() * 100.0;
        let directionFlip = 1.0;

        function hexToVec3(hex) {
            const r = parseInt(hex.slice(1, 3), 16) / 255;
            const g = parseInt(hex.slice(3, 5), 16) / 255;
            const b = parseInt(hex.slice(5, 7), 16) / 255;
            return [r, g, b];
        }

        function resetState() {
            for (let key in defaultConfig) {
                state[key] = defaultConfig[key].value;
            }
            regenerateSeed();
            updateUIFromState();
        }
        
        // New function to ensure motion is unique every time
        function regenerateSeed() {
            currentSeed = Math.random() * 1000.0;
            // Randomly flip flow direction (Clockwise vs Counter-Clockwise)
            directionFlip = Math.random() > 0.5 ? 1.0 : -1.0;
        }

        /**
         * SHADER SOURCES
         */
        const vsSource = `#version 300 es
        in vec4 a_position;
        void main() {
            gl_Position = a_position;
        }`;

        const fsSource = `#version 300 es
        precision highp float;

        uniform vec2 u_resolution;
        uniform float u_time;
        
        uniform vec3 u_colPrimary;
        uniform vec3 u_colDeep;
        uniform vec3 u_colLight;
        uniform vec3 u_colEdge;
        
        uniform float u_cylinderRadius;
        uniform float u_twistIntensity;
        uniform float u_vortexDepth;
        
        uniform float u_chaos;
        uniform float u_viscosity;
        uniform float u_liquidity;
        uniform float u_metalness;
        uniform float u_translucency;
        uniform float u_wineTone;
        
        uniform float u_waveAngFreq;
        uniform float u_waveAngAmp;
        uniform float u_waveRadFreq;
        uniform float u_waveRadAmp;
        
        uniform float u_camZoom;
        uniform float u_camRadius;
        uniform float u_viewAngle;
        
        uniform float u_twistSpeed;
        uniform float u_waveSpeed;
        uniform float u_fluidity;
        
        uniform float u_roughness;
        uniform float u_specular;
        uniform float u_lightY;
        
        uniform float u_seed;        // Unique seed per session
        uniform float u_direction;   // -1 or 1 flip

        out vec4 outColor;

        const int MAX_STEPS = 120;
        const float MAX_DIST = 60.0;
        const float SURF_DIST = 0.001;

        mat2 rot(float a) {
            float s = sin(a);
            float c = cos(a);
            return mat2(c, -s, s, c);
        }

        float hash(vec2 p) {
            return fract(sin(dot(p, vec2(12.9898 + u_seed, 78.233 + u_seed))) * 43758.5453);
        }

        float valueNoise(vec2 p) {
            vec2 i = floor(p);
            vec2 f = fract(p);
            f = f * f * (3.0 - 2.0 * f);
            float a = hash(i);
            float b = hash(i + vec2(1.0, 0.0));
            float c = hash(i + vec2(0.0, 1.0));
            float d = hash(i + vec2(1.0, 1.0));
            return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
        }

        float GetDist(vec3 p) {
            vec3 q = p;
            
            float speedMod = 1.0 - (u_viscosity * 0.7);
            
            // Base rotational flow - flipped by random u_direction
            // Also respecting user UI negative values if they manually set them
            float flowDir = sign(u_twistSpeed) * u_direction; 
            if(flowDir == 0.0) flowDir = 1.0;
            
            // Internal movement logic
            float internalFlow = u_time * (u_waveSpeed + u_fluidity * 2.0) * 0.02 * speedMod;
            float freqMod = 0.8 + u_liquidity * 2.0;
            
            // Animate domain warp with random seed offset
            vec2 warpOffset = vec2(internalFlow * flowDir + u_seed, internalFlow * 0.5);
            
            vec2 warp = vec2(
                valueNoise(q.xz * freqMod + warpOffset),
                valueNoise(q.xz * freqMod - warpOffset + 10.0)
            );
            
            float effectiveChaos = u_chaos * (1.0 - u_viscosity * 0.4);
            
            q.x += (warp.x - 0.5) * effectiveChaos;
            q.z += (warp.y - 0.5) * effectiveChaos;

            // Twist Logic
            // Abs speed for rotation calculation, direction handled by flowDir
            float twist = q.y * u_twistIntensity + u_time * abs(u_twistSpeed) * flowDir * 0.2 * speedMod;
            q.xz *= rot(twist);
            
            float r = length(q.xz);
            float a = atan(q.z, q.x);

            float vortex = u_vortexDepth * exp(-r * 2.5);
            
            // Add seed to wave phases so they don't look same every time
            float wavePhase = internalFlow * 1.5 * flowDir + u_seed;
            float wave1 = sin(a * u_waveAngFreq + wavePhase) * u_waveAngAmp * r;
            float wave2 = sin(r * u_waveRadFreq - internalFlow * 3.0 + u_seed) * u_waveRadAmp;
            
            float microNoise = valueNoise(q.xz * (4.0 + u_liquidity * 5.0) + internalFlow) * 0.05 * effectiveChaos * u_liquidity;

            float surfaceY = -0.5 + wave1 + wave2 + microNoise - vortex;
            float cylinder = length(q.xz) - u_cylinderRadius;
            
            float liquid = max(cylinder, q.y - surfaceY);
            liquid = max(liquid, -3.0 - q.y);
            
            return liquid * 0.5; 
        }

        float RayMarch(vec3 ro, vec3 rd) {
            float dO = 0.0;
            for(int i = 0; i < MAX_STEPS; i++) {
                vec3 p = ro + rd * dO;
                float dS = GetDist(p);
                dO += dS;
                if(dO > MAX_DIST || abs(dS) < SURF_DIST) break;
            }
            return dO;
        }

        vec3 GetNormal(vec3 p) {
            float d = GetDist(p);
            vec2 e = vec2(0.002, 0); 
            vec3 n = d - vec3(
                GetDist(p - e.xyy),
                GetDist(p - e.yxy),
                GetDist(p - e.yyx)
            );
            return normalize(n);
        }

        vec3 GetReflection(vec3 ref) {
            vec3 col = vec3(0.0);
            float y = ref.y * 0.5 + 0.5;
            col += vec3(0.05, 0.02, 0.02) * y;
            
            vec3 lightDir = normalize(vec3(0.8, 1.0, 0.5));
            float spec = pow(max(0.0, dot(ref, lightDir)), 20.0);
            col += spec * u_colLight * u_specular; 
            
            float rim = pow(1.0 + dot(ref, vec3(0,0,1)), 3.0);
            col += rim * vec3(0.2, 0.1, 0.1) * 0.5;
            return col;
        }

        void main() {
            vec2 uv = (gl_FragCoord.xy - 0.5 * u_resolution.xy) / u_resolution.y;

            // Camera
            float angle = u_viewAngle;
            float hRadius = u_camRadius * cos(angle);
            float vHeight = u_camRadius * sin(angle);
            
            // Random very slow orbit drift based on seed? No, keep camera steady as per request.
            vec3 ro = vec3(hRadius, vHeight, 0.0);
            // Re-add small time rotation to orbit?
            ro = vec3(cos(u_time * 0.05) * hRadius, vHeight, sin(u_time * 0.05) * hRadius);
            
            vec3 lookAt = vec3(0.0, -1.0, 0.0); 
            vec3 f = normalize(lookAt - ro);
            vec3 up = vec3(0.0, 1.0, 0.0);
            if(abs(dot(f, up)) > 0.99) { up = vec3(0.0, 0.0, -1.0); }
            vec3 r = normalize(cross(up, f));
            vec3 u = cross(f, r);
            vec3 rd = normalize(f * u_camZoom + r * uv.x + u * uv.y);

            float d = RayMarch(ro, rd);
            vec3 col = vec3(0.0);

            if(d < MAX_DIST) {
                vec3 p = ro + rd * d;
                vec3 n = GetNormal(p);
                vec3 ref = reflect(rd, n);
                vec3 lightPos = vec3(2.0, u_lightY, 2.0);
                vec3 l = normalize(lightPos - p);
                
                float dif = max(0.0, dot(n, l));
                
                float fresnel = pow(1.0 - max(0.0, dot(n, -rd)), 4.0);
                fresnel = mix(u_roughness, 0.95, fresnel);
                
                vec3 deepShifted = u_colDeep;
                vec3 darkTone = vec3(0.02, 0.0, 0.01);
                deepShifted = mix(deepShifted, darkTone, u_wineTone);
                
                float thickness = 0.5 + dot(rd, n) * 0.5; 
                vec3 sss = deepShifted * pow(1.0 - thickness, 2.0) * 3.0 * (1.0 - u_translucency);
                vec3 transColor = mix(deepShifted, u_colPrimary, thickness);
                transColor = max(transColor, deepShifted * 0.5); 
                vec3 transmission = transColor * u_translucency * 2.5;

                vec3 env = GetReflection(ref);
                vec3 baseMix = mix(u_colPrimary, deepShifted, dif * 0.4);
                vec3 bodyColor = baseMix + sss + transmission;
                
                col = mix(bodyColor, env, fresnel);
                
                float spec = pow(max(0.0, dot(ref, l)), 40.0);
                float specSharpness = 1.0 + u_liquidity; 
                col += spec * u_colLight * 2.0 * specSharpness;
                
                float edgeFactor = pow(1.0 - max(0.0, dot(n, -rd)), 3.0); 
                col += u_colEdge * edgeFactor * u_metalness;

                col *= smoothstep(-6.0, 1.0, p.y);
            } else {
                float bg = length(uv);
                col = mix(vec3(0.02, 0.0, 0.0), vec3(0.0), bg * 1.5);
            }

            col *= 1.0 - dot(uv, uv) * 0.6; 
            col = pow(col, vec3(0.4545));   

            outColor = vec4(col, 1.0);
        }`;

        /**
         * WEBGL BOILERPLATE
         */
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        const program = gl.createProgram();
        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vsSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error(gl.getProgramInfoLog(program));
        }

        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            -1, -1, 1, -1, -1, 1,
            -1, 1, 1, -1, 1, 1,
        ]), gl.STATIC_DRAW);

        const positionAttributeLocation = gl.getAttribLocation(program, "a_position");
        const vao = gl.createVertexArray();
        gl.bindVertexArray(vao);
        gl.enableVertexAttribArray(positionAttributeLocation);
        gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);

        const uniforms = {};
        const uNames = [
            'u_resolution', 'u_time', 
            'u_colPrimary', 'u_colDeep', 'u_colLight', 'u_colEdge',
            'u_cylinderRadius', 'u_twistIntensity', 'u_vortexDepth',
            'u_chaos', 'u_viscosity', 'u_liquidity', 'u_metalness', 'u_translucency', 'u_wineTone',
            'u_waveAngFreq', 'u_waveAngAmp', 'u_waveRadFreq', 'u_waveRadAmp',
            'u_camZoom', 'u_camRadius', 'u_viewAngle',
            'u_twistSpeed', 'u_waveSpeed', 'u_fluidity',
            'u_roughness', 'u_specular', 'u_lightY',
            'u_seed', 'u_direction'
        ];
        
        gl.useProgram(program);
        uNames.forEach(name => {
            uniforms[name] = gl.getUniformLocation(program, name);
        });

        /**
         * UI LOGIC
         */
        function generateUI() {
            let html = '';
            
            const groups = {
                'Camera': ['camZoom', 'camRadius', 'viewAngle'],
                'Shape & Scale': ['cylinderRadius', 'twistIntensity', 'vortexDepth'],
                'Style & Texture': ['viscosity', 'liquidity', 'fluidity', 'metalness', 'chaos'],
                'Color & Tone': ['colPrimary', 'colDeep', 'colLight', 'colEdge', 'translucency', 'wineTone'],
                'Waves': ['waveAngFreq', 'waveAngAmp', 'waveRadFreq', 'waveRadAmp'],
                'Motion': ['timeScale', 'twistSpeed', 'waveSpeed'],
                'Lighting': ['roughness', 'specular', 'lightY']
            };

            for (const [groupName, keys] of Object.entries(groups)) {
                html += `<div class="control-group"><h3>${groupName}</h3>`;
                
                keys.forEach(key => {
                    const conf = defaultConfig[key];
                    html += `<div class="control-row"><label>${conf.label}</label>`;
                    
                    if (conf.type === 'color') {
                        html += `<input type="color" id="in-${key}" value="${state[key]}">`;
                    } else {
                        html += `<input type="range" id="in-${key}" 
                                   min="${conf.min}" max="${conf.max}" step="${conf.step}" value="${state[key]}">`;
                    }
                    html += `</div>`;
                });
                
                html += `</div>`;
            }
            dynamicControls.innerHTML = html;

            for (let key in defaultConfig) {
                const el = document.getElementById(`in-${key}`);
                el.addEventListener('input', (e) => {
                    state[key] = defaultConfig[key].type === 'float' ? parseFloat(e.target.value) : e.target.value;
                });
            }
        }

        function updateUIFromState() {
            for (let key in state) {
                const el = document.getElementById(`in-${key}`);
                if (el) el.value = state[key];
            }
        }

        function randomizeState() {
            for (let key in defaultConfig) {
                const conf = defaultConfig[key];
                if (conf.type === 'color') {
                    const r = 50 + Math.floor(Math.random() * 200);
                    const g = Math.floor(Math.random() * 50);
                    const b = Math.floor(Math.random() * 50);
                    state[key] = "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
                } else {
                    const range = conf.max - conf.min;
                    const val = conf.min + Math.random() * range;
                    const stepped = Math.round(val / conf.step) * conf.step;
                    state[key] = stepped;
                }
            }
            state.waveAngAmp = Math.min(state.waveAngAmp, 0.25);
            state.chaos = Math.max(0.2, state.chaos);
            updateUIFromState();
        }

        function triggerTransition(actionCallback) {
            overlay.style.opacity = '1';
            setTimeout(() => {
                if (actionCallback) actionCallback();
                
                // Also regen seed on transition
                regenerateSeed();
                
                setTimeout(() => {
                    overlay.style.opacity = '0';
                }, 100);
            }, 400); 
        }

        let lastAutoTime = Date.now();
        const autoCheck = () => {
            const enabled = document.getElementById('auto-advance-toggle').checked;
            if (enabled) {
                const interval = parseInt(document.getElementById('auto-advance-timer').value) * 1000;
                if (Date.now() - lastAutoTime > interval) {
                    if(!settingsPanel.classList.contains('open')) {
                        triggerTransition(randomizeState);
                    }
                    lastAutoTime = Date.now();
                }
            }
        };

        // Time accumulator for time scaling
        let totalTime = 0;
        let lastFrameTime = performance.now();

        function render(now) {
            const dt = (now - lastFrameTime) * 0.001; 
            lastFrameTime = now;
            
            totalTime += dt * state.timeScale;
            
            autoCheck();

            const displayWidth = window.innerWidth;
            const displayHeight = window.innerHeight;
            if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
                canvas.width = displayWidth;
                canvas.height = displayHeight;
                gl.viewport(0, 0, canvas.width, canvas.height);
            }

            gl.useProgram(program);
            
            gl.uniform2f(uniforms.u_resolution, canvas.width, canvas.height);
            gl.uniform1f(uniforms.u_time, totalTime); 
            
            gl.uniform3fv(uniforms.u_colPrimary, hexToVec3(state.colPrimary));
            gl.uniform3fv(uniforms.u_colDeep, hexToVec3(state.colDeep));
            gl.uniform3fv(uniforms.u_colLight, hexToVec3(state.colLight));
            gl.uniform3fv(uniforms.u_colEdge, hexToVec3(state.colEdge));
            
            gl.uniform1f(uniforms.u_cylinderRadius, state.cylinderRadius);
            gl.uniform1f(uniforms.u_twistIntensity, state.twistIntensity);
            gl.uniform1f(uniforms.u_vortexDepth, state.vortexDepth);
            
            gl.uniform1f(uniforms.u_chaos, state.chaos);
            gl.uniform1f(uniforms.u_viscosity, state.viscosity);
            gl.uniform1f(uniforms.u_liquidity, state.liquidity);
            gl.uniform1f(uniforms.u_metalness, state.metalness);
            gl.uniform1f(uniforms.u_translucency, state.translucency);
            gl.uniform1f(uniforms.u_wineTone, state.wineTone);
            
            gl.uniform1f(uniforms.u_waveAngFreq, state.waveAngFreq);
            gl.uniform1f(uniforms.u_waveAngAmp, state.waveAngAmp);
            gl.uniform1f(uniforms.u_waveRadFreq, state.waveRadFreq);
            gl.uniform1f(uniforms.u_waveRadAmp, state.waveRadAmp);
            
            gl.uniform1f(uniforms.u_camZoom, state.camZoom);
            gl.uniform1f(uniforms.u_camRadius, state.camRadius);
            gl.uniform1f(uniforms.u_viewAngle, state.viewAngle);
            
            gl.uniform1f(uniforms.u_twistSpeed, state.twistSpeed);
            gl.uniform1f(uniforms.u_waveSpeed, state.waveSpeed);
            gl.uniform1f(uniforms.u_fluidity, state.fluidity);
            
            gl.uniform1f(uniforms.u_roughness, state.roughness);
            gl.uniform1f(uniforms.u_specular, state.specular);
            gl.uniform1f(uniforms.u_lightY, state.lightY);
            
            // Send random seed and direction to shader
            gl.uniform1f(uniforms.u_seed, currentSeed);
            gl.uniform1f(uniforms.u_direction, directionFlip);

            gl.drawArrays(gl.TRIANGLES, 0, 6);
            requestAnimationFrame(render);
        }

        // Init
        regenerateSeed(); // Start with random flow
        resetState(); 
        generateUI();
        requestAnimationFrame(render);

        // Menu Logic
        function toggleMenu() {
            settingsPanel.classList.toggle('open');
            document.body.classList.toggle('menu-open');
        }

        function closeMenu() {
            settingsPanel.classList.remove('open');
            document.body.classList.remove('menu-open');
        }

        menuBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            toggleMenu();
        });
        
        closeBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            closeMenu();
        });

        document.addEventListener('click', (e) => {
            if (settingsPanel.classList.contains('open')) {
                if (!settingsPanel.contains(e.target) && e.target !== menuBtn) {
                    closeMenu();
                }
            } else {
                if(e.target === canvas) {
                    triggerTransition(randomizeState);
                    lastAutoTime = Date.now(); 
                }
            }
        });

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') closeMenu();
        });

        document.getElementById('btn-randomize').addEventListener('click', () => {
            triggerTransition(randomizeState);
        });

        document.getElementById('btn-reset').addEventListener('click', () => {
            triggerTransition(resetState);
        });

        document.getElementById('btn-save').addEventListener('click', () => {
            const data = JSON.stringify(state, null, 2);
            const blob = new Blob([data], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `vessel-reformed-config-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
        });

        document.getElementById('btn-load').addEventListener('click', () => {
            fileInput.click();
        });

        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (ev) => {
                try {
                    const loadedState = JSON.parse(ev.target.result);
                    for (let key in defaultConfig) {
                        if (loadedState.hasOwnProperty(key)) {
                            state[key] = loadedState[key];
                        }
                    }
                    if(state.viscosity === undefined) state.viscosity = 0.5;
                    if(state.liquidity === undefined) state.liquidity = 0.5;
                    if(state.fluidity === undefined) state.fluidity = 0.5;
                    if(state.metalness === undefined) state.metalness = 0.6;
                    if(state.translucency === undefined) state.translucency = 0.2;
                    if(state.wineTone === undefined) state.wineTone = 0.0;
                    if(state.colEdge === undefined) state.colEdge = '#ffffff';
                    if(state.timeScale === undefined) state.timeScale = 1.0;
                    
                    if(state.viewAngle === undefined && loadedState.camTilt !== undefined) {
                        state.viewAngle = 0.5; 
                    }
                    
                    triggerTransition(updateUIFromState);
                } catch(err) {
                    alert("Invalid config file");
                }
            };
            reader.readAsText(file);
            e.target.value = '';
        });

        document.getElementById('btn-export').addEventListener('click', () => {
            const prevW = canvas.width;
            const prevH = canvas.height;
            canvas.width = 3840;
            canvas.height = 2160;
            gl.viewport(0, 0, 3840, 2160);
            
            gl.useProgram(program);
            gl.uniform2f(uniforms.u_resolution, 3840, 2160);
            gl.uniform1f(uniforms.u_time, totalTime); 
            
            gl.uniform3fv(uniforms.u_colPrimary, hexToVec3(state.colPrimary));
            gl.uniform3fv(uniforms.u_colDeep, hexToVec3(state.colDeep));
            gl.uniform3fv(uniforms.u_colLight, hexToVec3(state.colLight));
            gl.uniform3fv(uniforms.u_colEdge, hexToVec3(state.colEdge));
            gl.uniform1f(uniforms.u_cylinderRadius, state.cylinderRadius);
            gl.uniform1f(uniforms.u_twistIntensity, state.twistIntensity);
            gl.uniform1f(uniforms.u_vortexDepth, state.vortexDepth);
            
            gl.uniform1f(uniforms.u_chaos, state.chaos);
            gl.uniform1f(uniforms.u_viscosity, state.viscosity);
            gl.uniform1f(uniforms.u_liquidity, state.liquidity);
            gl.uniform1f(uniforms.u_metalness, state.metalness);
            gl.uniform1f(uniforms.u_translucency, state.translucency);
            gl.uniform1f(uniforms.u_wineTone, state.wineTone);
            
            gl.uniform1f(uniforms.u_waveAngFreq, state.waveAngFreq);
            gl.uniform1f(uniforms.u_waveAngAmp, state.waveAngAmp);
            gl.uniform1f(uniforms.u_waveRadFreq, state.waveRadFreq);
            gl.uniform1f(uniforms.u_waveRadAmp, state.waveRadAmp);
            gl.uniform1f(uniforms.u_camZoom, state.camZoom);
            gl.uniform1f(uniforms.u_camRadius, state.camRadius);
            gl.uniform1f(uniforms.u_viewAngle, state.viewAngle);
            gl.uniform1f(uniforms.u_twistSpeed, state.twistSpeed);
            gl.uniform1f(uniforms.u_waveSpeed, state.waveSpeed);
            gl.uniform1f(uniforms.u_fluidity, state.fluidity);
            
            gl.uniform1f(uniforms.u_roughness, state.roughness);
            gl.uniform1f(uniforms.u_specular, state.specular);
            gl.uniform1f(uniforms.u_lightY, state.lightY);
            
            // Export also gets random direction/seed
            gl.uniform1f(uniforms.u_seed, currentSeed);
            gl.uniform1f(uniforms.u_direction, directionFlip);
            
            gl.drawArrays(gl.TRIANGLES, 0, 6);
            
            const link = document.createElement('a');
            link.download = `VesselReformed_${Date.now()}.png`;
            link.href = canvas.toDataURL("image/png");
            link.click();
            
            canvas.width = prevW;
            canvas.height = prevH;
            gl.viewport(0, 0, prevW, prevH);
        });

        document.getElementById('auto-advance-timer').addEventListener('input', (e) => {
            document.getElementById('timer-display').textContent = e.target.value + 's';
        });

    </script>
</body>
</html>